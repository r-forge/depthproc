#'@title Depth calculation
#'
#'@description Computes the depth of a point or vectors of points with respect to a multivariate data set.
#'
#'  @param u Numerical vector or matrix whose depth is to be calculated. Dimension has to be the same as that of the observations.
#'  @param X The data as a matrix, data frame or list. If it is a matrix or data frame, then each row is viewed as one multivariate observation. If it is a list, all components must be numerical vectors of equal length (coordinates of observations).
#'  @param method Character string which determines the depth function. \code{method} can be "Projection" (the default), "Mahalanobis", "Euclidean" or "Tukey". For details see \code{\link{depth}.}
#'  @param ndir Number of random directions used when Projection and Tukey depth is approximated.
#'
#'
#'@details 
#'  
#'  Irrespective of dimension, Projection and Tukey's depth is obtained by approximate calculation. 
#'  
#'  Calculation of Mahalanobis and Euclidean depth is exact.
#'  
#'
#'  
#'  Returns the depth of multivariate point \code{u} with respect to data set \code{X}.
#'  
#'  @references 
#'  
#'  Liu, R.Y., Parelius, J.M. and Singh, K. (1999), Multivariate analysis by data depth: Descriptive statistics, graphics and inference (with discussion), \emph{Ann. Statist.}, \bold{27}, 783--858.
#'  
#'  Rousseuw, P.J. and Ruts, I. (1996), AS 307 : Bivariate location depth, \emph{Appl. Stat.-J. Roy. S. C},  \bold{45}, 516--526.
#'  
#'  Rousseeuw, P.J. and Struyf, A. (1998), Computing location depth and regression depth in higher dimensions, \emph{Stat. Comput.}, \bold{8}, 193--203.
#'  
#'  Zuo, Y. amd Serfling, R. (2000), General Notions of Statistical Depth Functions, \emph{Ann. Statist.},  \bold{28}, no. 2, 461--482.
#'  
#'  @author Daniel Kosiorowski, Mateusz Bocian, Anna Wegrzynkiewicz and Zygmunt Zawadzki from Cracow University of Economics.
#'  
#'  @seealso \code{\link{depthContour}} and \code{\link{depthPersp}} for depth graphics.
#'  
#'  @examples
#'  ## Calculation of Projection depth
#'  data(starsCYG, package = "robustbase")
#'  depth(t(colMeans(starsCYG)), starsCYG)
#'  
#'  #Aslo for matrices
#'  depth(starsCYG, starsCYG)
#'  
#'  ## Projection depth applied to a large bivariate data set
#'  set.seed(356)
#'  x <- matrix(rnorm(9999), nc = 3)
#'  depth(x, x)
#'  
#'  
#'  
#'  @keywords
#'  multivariate
#'  nonparametric
#'  robust
#'  depth function
#'  
#'


depth = function(u, X, method="Projection", ndir=1000, digits=2)
{
    
  if(is.data.frame(u)) u = as.matrix(u)
  if(is.data.frame(X)) X = as.matrix(X)
  
set.seed(1)
if(is.vector(X)) X = matrix(X,ncol = 1)
if(is.vector(u)) u = matrix(u,ncol = dim(X)[2])

#######################################################################
if (method=="Mahalanobis")
{	
	cov = cov(X)
	center = colMeans(X)
	
	icov = solve(cov)
	
	d <- function(u,center = center, icov = icov)
 	{
		depth<-1/(1+t(u-center)%*%icov%*%(u-center))
		depth	
	}
										
	depth = apply(u,1,d,center,icov)         
}

######################################################################
if (method=="Euclidean")
{
				n = dim(u)[1]
				
				center = colMeans(X)
				center = matrix(rep(center,n),nrow=n,byrow=TRUE)
				depth=1/(1+(rowSums((u-center)^2)))	
}

####################################
  
if(method == "Projection")
{
    proj = runifsphere(ndir, ncol(X))
    depth = .Call("projection",PACKAGE = "depthproc",X,X,proj,ncol(X),nrow(X),nrow(u),nrow(proj))
}
  
# if (method=="Projection")  
# {
# 
#   projection_depth_1d =function(u,X, location=median, scale=mad)
#   {
#     depth = 1/(1+abs(u-location(X))/scale(X))
#   }
#   
#   if (ncol(X)==1)
#   {
#     depth=projection_depth_1d(u,X)
#   }
#   else
#   {
# 
#     proj = runifsphere(ndir, ncol(X))
#     
#     xut = tcrossprod(X,proj)
#     uut = tcrossprod(u,proj)
#  
#     tmp = .Call("colMediansMads",PACKAGE = "depthproc",xut,nrow(xut),ncol(xut))
#   
#     MED = tmp[1:ncol(xut)]
#     MAD = tmp[(ncol(xut)+1):(2*ncol(xut))]
#     
#     
#     OD<-(1/(1+(abs(t(uut)-MED)/MAD)))
#     
#     depth<-apply(OD,2,min)
#     depth
#   }
# }


#######################################################################
if (method=="Tukey")
{
 
  	tukey1d = function(u,X)
		{
		  Xecdf = ecdf(X)
			uecdf = Xecdf(u) 
			uecdf2 = 1-uecdf
			min.ecdf = uecdf>uecdf2
			depth = uecdf 
			depth[min.ecdf]=uecdf2[min.ecdf] 
			depth
		}
  
  if (ncol(X)==1)
  {
  depth= tukey1d(u,X)
  }
  
#### 
  else  # czyli jesli wymiar d>2
  {
  
  
  proj = t(runifsphere(ndir, ncol(X)))
  xut = X%*%proj
  uut = u%*%proj
  
  OD<-matrix(nrow=nrow(uut),ncol=ncol(uut))
  
	for (i in 1:ndir)
	{
	
    OD[,i]=tukey1d(uut[,i],xut[,i])  
	}
 
	depth<-apply(OD,1,min)
  
  rm(.Random.seed, pos = 1)
  }
}


########################################################

depth
}

